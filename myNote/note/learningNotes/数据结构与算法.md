# 数据结构与算法

## 数据结构

![](https://pic.leetcode-cn.com/1599638810-SZDwfK-Picture1.png)

线性数据解构：一对一；

- 栈Stack：先入后出；
  - js：可利用数组结合push()和pop()实现（即，从数组末尾入栈和出栈）；
- 队列Queue：先入先出；
  - js：可利用数组结合push()和shit()实现（即，从数组末尾入队，数组开头出队）



非线性数据结构：一对多；

- 树Tree：可分为二叉树和多叉树；

  - js：可以借助构造函数实现

    ```javascript
    	//二叉树
    		function treeNode(a){
                this.node=a;
                this.leftNode={};
                this.rightNode={};
            };
            let rootNode=new treeNode('fa');
            let sonNode=new treeNode('son');
            let daNode=new treeNode('da');
            rootNode.leftNode=sonNode;
            rootNode.rightNode=daNode;
            console.log(rootNode)
    ```

  

- 散列表Hashing：通过Hash函数将健key映射到值value，以实现时间复杂度为O(1)的查找速率；

  - js：
    1. 使用Map类型（基于Hash结构）
    
    2. 使用数组存储value，Hash函数映射查找值到数组对应下标地址 
    
       

- 图Graph：由点Vertex和边edge组成，每条边连接两个点。可分为有向图和无向图；

  - js：点和边可以分别用一维数组和二维数组表示

  ```javascript
  vertices = [1, 2, 3, 4, 5]
  //边有两种表示形式，邻接矩阵和邻接表
  //邻接矩阵，横纵坐标均为点vertices[0]~vertices[4]
  edges = [
      [0, 1, 1, 1, 1],
      [1, 0, 0, 1, 0],
      [1, 0, 0, 0, 1],
      [1, 1, 0, 0, 1],
      [1, 0, 1, 1, 0],
           ]
  //邻接表，纵坐标为点vertices[0]~vertices[4]，横坐标为只与该点相连的点
  edges2=[
      [0,1,2,3,4],
      [0,1,2],
      [1,3,4],
      [3],
      [2,4]
  ]
  ```

  减少内存开销：

  邻接矩阵：适合相对**点少边多**的图；

  邻接表：适合相对**点多边少**的图；




- 堆Heap：基于完全二叉树，分为大顶堆和小顶堆两种。

> 完全二叉树：除最底层外，节点全部占满，且最底层节点均集中在左边；
>
> 大（小）顶堆：任意节点的值不大于（小于）其父节点；

