# Webpack

作为一个打包工具，实现的两个主要功能：内容转换+资源合并；

同样的工具还有Rollup、vite等；



以下内容基于webpack 5，代码基于最新的v5.91.0（time: 24.6.10）;

## 流程

> 1. 初始化阶段：
>    1. **初始化参数**：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数
>    2. **创建编译器对象**：用上一步得到的参数创建 `Compiler` 对象
>    3. **初始化编译环境**：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等
>    4. **开始编译**：执行 `compiler` 对象的 `run` 方法
>    5. **确定入口**：根据配置中的 `entry` 找出所有的入口文件，调用 `compilition.addEntry` 将入口文件转换为 `dependence` 对象
> 2. 构建阶段：
>    1. **编译模块(make)**：根据 `entry` 对应的 `dependence` 创建 `module` 对象，调用 `loader` 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理
>    2. **完成模块编译**：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 **依赖关系图**
> 3. 生成阶段：
>    1. **输出资源(seal)**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `Chunk`，再把每个 `Chunk` 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
>    2. **写入文件系统(emitAssets)**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统
>
> 参考：https://mp.weixin.qq.com/s/SbJNbSVzSPSKBe2YStn2Zw



总体流程就是：

创建complier对象，执行run()，从entry进入，将每个js（包括使用到的其他资源）转换为对应的module对象，module会交由loader进行编译转换，同时这个过程也会生成对应的ast（语法树），babel也就是这个时候处理源码。当前module处理完后，如果存在依赖（判断js文本有require或者import），就递归处理该依赖（生成对应module）。

所有依赖都处理成了module后，开始打包。此时分析之前递归的依赖关系，把mudule划分到不同的chunk，一个chunk就对应一个输出文件，生成一个chunk集合（比如，从entry import的多个js为一个chunk，动态导入的为一个chunk）。最后，根据配置调用plugin，整合每个chunk的资源，输出打包后的新文件。
