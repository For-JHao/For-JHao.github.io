# TCP连接机制

结构：借用图片

<img src='https://img2020.cnblogs.com/blog/1614350/202012/1614350-20201209214135907-692951274.png' style='margin-left:0'/>

序列号（seq number）：用于标识每次传输的数据顺序，基于此检测数据丢失和重复；通信双方各自维护自己序列号。

确认号(ack number)：对方发过来的期望下次收到的序列号。即意味着""确认号-1"已经被接收。

标志位：包括ACK, SYN, FIN等标识，每个占一位，即只能是0或1，可以互相组合来标识不同报文类型。

根据字意可知，ACK：表示确认；SYN：表示同步（序号）；FIN：表示结束



注意：区分标志位ACK（1位），和确认号字段ack Number（32位）



## 三次握手

具体指三次报文传输，目的是建立一个可靠的TCP连接：确保双方准备好数据传输；双方都获取初始序列号

1. 客户端：发送**SYN**=1报文，表示建立请求；

   seq携带一个客户端的初始序列号（ISN，假设为x），通常由随机数产生。

2. 服务端：发送**SYN **& **ACK**=1报文，SYN表示让对方同步自己序列号，ACK表示确认收到对方序列号；

   seq携带服务端的初始序列号。

   ack携带 ”对方序列号x+1“

3. 客户端：发送ACK=1，表示收到对方序列号；

   seq: 客户端 ”自己序列号+1“, 即同样也是x+1（只基于自己发送的数据增加)

   ack: ”对方序列号+1“

   

总而言之，三次握手就是互相交换序列号，并要确认对方收到。

序列号增量代表着传输数据的字节量。在三次握手时序列号+1，但在后续数据传输过程中，因为tcp每次传输的数据大小是动态的，序列号增加也是动态的。



## 四次挥手

TCP是全双工通信，因此结束连接需要确认双方都传输完毕。

> 全双工：即双方可以同时各自发送和接受数据；

1. 客户端：发送FIN=1

   seq: x

2. 服务端：发送ACK=1

   seq: y

   ack:x+1

   此时服务端仍然可以保持连接，继续发送数据

3. 服务端：发送FIN=1

   seq: z (在y后，可能发送了多个)

4. 客户端：ACK=1，进入 TIME_WAIT 状态

   seq: x+1 （只在自己序列号上+1）

   ack: z+1 

   等待是为了确认服务端收到了客户端的ACK，否则服务端不知道关闭；如果服务端没收到，会重新发送FIN。

   等待一段时间无异常后，客户端关闭。

   

   理论上讲，全双工最后一方是无法完全确认对方关闭的，这里客户端先发起FIN，最后收到服务端FIN后，客户端能够安心确认关闭。

   但一方关闭后，就无法确认对方情况。如果最后的客户端的ACK丢失，同时超过了等待时间，服务端就只能通过超时自动关闭。

