# 事件循环event loop

JS属于单线程语言，同一时间只能处理一个事件（函数）；



*注意：以下事件循环基于浏览器层面，高于v8引擎*

事件执行遵循以下顺序循环
**同步-->微任务-->一个宏任务**

其中微任务和宏任务属于异步任务，分别有一个对应的微任务队列和宏任务队列存放事件；

在一次循环中，每当上一类型任务全部清空时，才进行下一类型；

具体循环动作：

1. 同步任务直接放入**执行栈**，遵守**先进后出**运行；栈中的函数产生的异步任务，按类型分别放入微任务**队列**和宏任务**队列**，遵守**先入先出**；

2. 执行栈清空后，从微任务队首，依次，取单个任务放入栈执行，直至微任务清空（包括微任务新加的微任务）；

3. 执行宏任务。宏任务队列，每次只会取队首的一项，该任务执行完毕后，便复查有没有因此加入的新微任务，当前微任务再清空，（UI render），再取下一项宏任务，如此循环清空宏任务；

*补充*

- 浏览器如果需要**渲染**，会在微任务清空后，下一项宏任务前执行；
- 执行栈，用于存储调用的函数；对象则分配在堆中（一大块内存）；

微任务

> - new Promise().then(回调)        //注意：promise()回调是同步，then()回调才是异步
> - MutationObserver(html5 新特性，监视DOM的更改)
> - catch/finally
> - async/await

宏任务：

> - script(整体代码)
> - setTimeout()
> - setInterval()
> - postMessage：用于跨域通信
> - I/O
> - UI交互事件

定时器，如setTimeout()，作为宏任务，会在同步任务及微任务全部清空后才会执行；

js代码由JavaScript引擎执行，单线程；而定时器的计数是交给额外的浏览器线程计算，计数完成后将事件回调加入**宏任务队列**。

定时器的第二个参数实际为任务**加入队列**的最小延迟时间，到达该时间后加入队列，还要等队列前面的任务都执行完才会执行；

*补充*：

HTTP请求也是由浏览器单独的线程处理；

一次事件循环可以视为由一个宏任务开启（加载scrip也是宏任务）；