# 原型和原型链

JS是一门基于原型的语言；

而本身该设计模式，是用于解决继承问题；

JS几乎所有的变量都可以视为对象，而所有的对象都通过原型继承于内置数据类型Object的原型；



## 基本模型

涉及两个关键属性：**[[prototype]]**和**prototype；**

**[[prototype]]**：即原来的`__proto__`，作为**对象**的固有属性，指向其构造函数的**原型**（**prototype**）

**prototype**：即通常说的**原型**（对象），作为**函数**的固有属性，指向函数的**原型**



所以，一个**实例对象的[[prototype]]**和其**构造函数prototype**指向的是一个东西（**都是指向的原型对象**）



即，该模型一共涉及三个对象：实例对象，函数对象，函数的原型对象；



## 原型对象

（系统自身创建的）原型对象，都有一个属性**constructor**，通过该属性指回其关联的函数本身；

（额外，可以通过`Object.setPrototypeOf(bb,b)`，手动把一个普通对象b设为bb的原型对象）

系统创建的原型对象，则是由内置Object类型作为构造函数创建。

所以同理，理论上，原型对象的[[prototype]]指向Object的prototype；

实际浏览器实现似乎有差异，通过控制台发现又包装了几层中间对象，应该是为了保护内置对象和原型方法。但最终都会指向Object的prototype



**Note**，每个内置数据类型，比如Function，Array，都有一个自己的原型，而这个原型的原型则为Object的原型



### 原型链

综上：

理论上，一个标准的原型链，所有`obj.[[prototype]]`指向原型，标准原型的[[prototype]]指向内置数据类型Object的原型，Object的原型指向Null（例外）;

即，`obj.[[prototype]].[[prototype]]....[[prototype]]=null`，最后也相当于`Object.prototype.__proto__ === null`

原型链，即通过`[[prototype]]`（包括\__proto__）接起来的链接；查找变量的属性时，所谓的原型链攀升就是通过`[[prototype]]`一层一层查找；

而**prototype**仅为函数的属性，给函数标明关联的原型，并不在原型链攀升上；很多地方的解释，原型链用**prototype**标注(因为和**obj.[[prototype]]**指向同一个地址，也没错)，反而造成理解困难





## 创建原型的方法



