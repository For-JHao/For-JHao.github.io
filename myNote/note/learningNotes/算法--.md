# 算法

## 排序算法

基本排序就是两两比较，两次遍历嵌套，事件复杂度n^2。冒泡，选择，插入排序本质都是这样；

像这样每次只找一个最值，浪费了很多比较结果；

在这基础上的优化算法，包括快排，堆排，希尔，归并等，本质就是在两两比较时，将每次的比较结果尽可能利用起来，通过切换索引位置将信息存起来（不管是分组，还是以树的形式），以减少之后的比较次数；

还有一种思路，就是用空间换时间，包括计数排序，桶排序，基数排序。不是基于两两比较，而是按照数据特征开辟新的空间（比如利用一个新的数组，将数据’5‘放在arr[5]），借助坐标映射数据以提高查找速度。这种方式能突破比较算法最快nlogn的时限，但是需要大量额外空间。





## **动态规划（DP）**

**本质：**

动态规划（Dynamic Programming）本质上是一种 **优化过的递归+记忆化** 方法，它通过 **分解问题** + **记录子问题最优解** 来避免重复计算，从而 **降低时间复杂度**。

### **🔹 核心思想**

1. **最优子结构**：
    一个问题的最优解可以通过 **子问题的最优解** 推导出来。
2. **重叠子问题**：
    大问题可以拆分成多个 **重复的小问题**，而这些子问题的解可以被复用。
3. **状态转移方程**：
    通过某种公式，将较小规模的子问题推导到较大规模的问题。



**五步分析法 **

| 步骤                     | 关键问题                                    |
| ------------------------ | ------------------------------------------- |
| 1. 定义状态 `dp[i]`      | **“`dp[i]` 代表什么意思？”**                |
| 2. 找状态转移方程        | **“`dp[i]` 如何由 `dp[j]` 推导？”**         |
| 3. 初始化 `dp[0], dp[1]` | **“最简单情况是什么？”**                    |
| 4. 确定计算顺序          | **“递推（自底向上）or 递归（自顶向下）？”** |
| 5. 返回最终答案          | **“整个 `dp` 数组里的最大/最小值？”**       |