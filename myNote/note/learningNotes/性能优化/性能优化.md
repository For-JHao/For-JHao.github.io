# 性能优化

性能主要体现在两方面：时间和空间；

耗时主要有两部分，加载时间和网络请求时间；

通常减低空间的方案也能有利于降低时间消耗；

## 时间

- 异步加载和延迟执行

正常情况下js文件加载和执行都是同步执行，会阻塞浏览器其他工作；

在JS内容不会影响页面初次渲染的情况下（例，DOM操作），可以采用异步加载或延迟执行；

JS异步加载：script标签使用defer属性（所有defer脚本按顺序执行）；或async属性（html5，多个async脚本不保证按顺序执行）；

JS延迟执行：JS文件一旦下载完会立即执行，延迟执行是通过使用对象等方式缓存JS内容，再在需要的时候调用；

- 合理搭配懒加载和预加载

将不紧要的资源懒加载，避免占用主要模块的加载时间；

在不影响当前使用资源的情况下，预加载后续可能需要的资源；

- 使用反向代理（代理外部向内部发起请求）

在用户和目标服务器之间设置代理服务器作为中转站，可通过代理服务器分流减少网络拥堵，从而加快网络请求速度；同时反向代理可以隐藏真实服务接口，提高内部服务器安全性；

- 合理使用缓存

合理配置本地缓存、云缓存策略减少不必要的网络请求以及数据传输；使用CDN（content delivery network）降低物理传输耗时，同时也能降低服务器压力（加快处理速度）

- 优化js执行时间

例如，因为js引擎线程和GUI渲染线程是互斥的，如果在js中触发了重绘（repaint）或者回流（flow），又马上去获取该dom样式，就会导致js暂停先去执行GUI线程。也意味着，在这个时间内会阻塞用户的操作。

- 减少体积

减少数据量的同时也能降低传输时间。具体方式同下。

## 空间

- 压缩资源

HTML/CSS/JavaScript，以及图片等文件都可以通过压缩减少体积；

构建项目时，可配置webpage的compression-webpack-plugin插件压缩；

网络传输时，HTTP协议也支持直接下载Gzip文件；请求头使用Accept-Encoding，响应头使用Content-Encoding；浏览器会自动解析指定的压缩文件；

> gzip只会压缩响应体的数据。
>
> 由于算法原因，压缩需要添加额外信息，如果文件本来就小，压缩后的文件可能会更大。
>
> gzip同样不适合压缩音频、图片等文件，这类文件本来就已经被压缩为了二进制文件。
>
> 参考：[gzip算法介绍](https://segmentfault.com/a/1190000020386580)



- 分包和按需加载

拆分主包，按需加载所需资源，或根据需要异步加载；

webpage有三种分包操作；

1. 在entry手动配置多个入口，会生成多个包；
2. 使用import()加载的模块也会分离成单独的包；
3. 使用插件splitChunks，会按配置规则从主文件分离模块打包；

## 用户体验

1. 通常认为，TTI控制在50ms内体验会比较**流畅**，超过5s体验会非常差
2. 设计0结果展示界面，包括加载等待、请求失败等
3. 点击区域优化；对于过小的点击目标，使用伪元素扩大点击区域；
4. 脚本执行期间，浏览器无法响应用户任何操作，将处理时间过长的脚本异步执行；
5. 采用渐进式编码图片，或者基行编码的图片，前者图片会从模糊到清晰，后者会一行一行加载；这都是浏览器根据编码的自行处理；

## 通用

- 减少http请求
- 将 CSS 放在文件头部，JavaScript 文件放在底部
- 减少回流（布局修改）
- 及时解绑事件监听
- 使用事件委托，即利用冒泡机制，减少子元素上的事件绑定数量
- 及时清理定时器
- 处理超时的异步回调

图片

- 使用字体图标 iconfont 代替图片图标
- 合理利用预加载和懒加载；
- 尽可能利用 CSS3 效果代替图片
- 适当压缩图片



其他参考：https://web.dev/learn/performance/welcome?hl=zh-cn
